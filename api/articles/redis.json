{"title":"redis","uid":"eb5f3adb17521be888d5fac1c7b84dc0","slug":"redis","date":"2023-12-07T16:34:56.000Z","updated":"2023-12-08T01:33:08.633Z","comments":true,"path":"api/articles/redis.json","keywords":null,"cover":[],"content":"<h1 id=\"一、内容整理\"><a href=\"#一、内容整理\" class=\"headerlink\" title=\"一、内容整理\"></a>一、内容整理</h1><h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><h4 id=\"1-缓存穿透\"><a href=\"#1-缓存穿透\" class=\"headerlink\" title=\"1. 缓存穿透\"></a>1. 缓存穿透</h4><p>有大量的请求访问不存在的 key，首先访问 redis，发现不存在当前 key 后 后再访问数据库，因为并不存在这条数据，当前查询的结果为 <code>null</code>，也不会在 redis 中建立缓存，导致所有的请求全都打在数据库上，导致数据库崩溃</p>\n<ul>\n<li>缓存中添加空值<br>优点：实现简单<br>缺点：造成内存资源的浪费</li>\n<li>布隆过滤器：创建一个比较大的数组，利用比特位，通过计算 key 的多个 hash 值，将对应位的值变为 1，请求时先经过布隆过滤器，通过计算目标 key 的 hash 判断对应位置的值是否全为 1 判断是否存在，但有误判的可能：一个 key 的 hash 对应到两个不同 key 的 hash 的比特位。<br>优点：不会造成内存资源的浪费<br>缺点：增加过滤器，会降低一些性能，实现较为复杂，有一定概率会误判。</li>\n</ul>\n<h4 id=\"1-缓存击穿\"><a href=\"#1-缓存击穿\" class=\"headerlink\" title=\"1. 缓存击穿\"></a>1. 缓存击穿</h4><p>某个热点 key 突然失效，所有的请求都打到数据库，导致数据库的崩溃</p>\n<ul>\n<li>设置互斥锁：当缓存失效后，通过 setnx 设置一个互斥锁，拿到这把锁的线程去进行缓存重建<br>优点：数据一致性较强<br>缺点：性能较低，可能产生死锁问题</li>\n<li>设置逻辑过期时间：在建立缓存时当前缓存不设置过期时间，而是加入一个逻辑过期时间，查询后直接返回值并判断比较当前时间和逻辑过期时间，如果过期，开启另一个线程进行数据的同步。<br>优点：效率较高，性能不会有明显下降<br>缺点：过期后，返回的仍旧是旧数据，数据一致性较差</li>\n</ul>\n<h4 id=\"2-缓存雪崩\"><a href=\"#2-缓存雪崩\" class=\"headerlink\" title=\"2. 缓存雪崩\"></a>2. 缓存雪崩</h4><p>在某个时间，大量的 key 同时失效</p>\n<ul>\n<li>在创建缓存时，在设置的过期时间后添加一个随机数</li>\n</ul>\n<h4 id=\"3-双写一致性\"><a href=\"#3-双写一致性\" class=\"headerlink\" title=\"3. 双写一致性\"></a>3. 双写一致性</h4><p>数据库和缓存数据的一致性</p>\n<ul>\n<li>可以接受一定延时：双删，删除缓存，更新数据库，再删除一次缓存<br>更新数据时分为先更新数据库和先删除缓存，两者都有可能产生数据的不一致<br><img src=\"/image/redis/1689438549264.png\" alt=\"1689438549264\"><br><img src=\"/image/redis/1689438479837.png\" alt=\"1689438479837\"><br>其中先删数据库的方式发生的概率要远远小于先删除缓存<br>优点：实现较为简单<br>缺点：延时的时长不好控制，有一定的概率产生脏数据，可以使用消息队列，对缓存进行更改，避免脏数据的产生（canal）</li>\n<li>强一致性：采用的是 redisson 实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据</li>\n</ul>\n<h4 id=\"4-持久化\"><a href=\"#4-持久化\" class=\"headerlink\" title=\"4. 持久化\"></a>4. 持久化</h4><ul>\n<li>RDB（内存快照）保存的是 redis 某一时刻的数据快照，主线程 fork 一个子线程，在内存空间中共享一个页表，能够访问到相同的内存，子线程完成内存快照的保存，可以通过配置 save 设置多少时间内修改多少个 key 保存快照<br>优点：数据量较小<br>缺点：发生宕机时，丢失的数据相对较多</li>\n<li>AOF（命令）保存的是一条一条的 redis 命令，可以通过更改 appendfsync 配置保存增加命令的时间间隔，通过！！！配置将指令重排，将对同一个 key 的多次操作合并成一个，以减少数据量<br>优点：发生宕机时丢失数据相对较少<br>缺点：数据量较大</li>\n</ul>\n<h4 id=\"5-数据过期策略\"><a href=\"#5-数据过期策略\" class=\"headerlink\" title=\"5. 数据过期策略\"></a>5. 数据过期策略</h4><p>当到了 key 设置的过期时间后，从内存中删除 key 的策略</p>\n<ul>\n<li>惰性删除：到了过期时间后，不会立即删除内存中的 key 而是等到再次访问这个 key 的时候返回 <code>null</code>并从内存中删除</li>\n<li>定期删除：按照一定的时间间隔扫描所有的 key，发现到了过期时间了再删除，该操作的时间不能超过设置的时长，超过设置时长会直接结束，等待下一轮</li>\n</ul>\n<h4 id=\"6-数据淘汰策略\"><a href=\"#6-数据淘汰策略\" class=\"headerlink\" title=\"6. 数据淘汰策略\"></a>6. 数据淘汰策略</h4><p>当系统无可用内存时 redis 的行为，默认设置的是直接拒绝设置 key 的请求，另外还可以设置淘汰策略，例如随机，按照访问频率等，其中有两个重要概念 LRU 和 LFU，LRU（最近最少使用）当前时间减去每个 key 最后一次访问的时间，得到每个 key 没有被访问的时长，LFU（最少频率使用）一段时间内每个 key 的访问次数</p>\n<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><ol>\n<li>使用场景<br>分布式系统中一个应用部署在多台服务器上，内存不在同一个空间</li>\n<li>分布式锁-实现原理（setnx、redisson）<br>使用 setnx 命令（实际使用 set lock 1 nx ex 10 的形式，相比 setnx 保证锁和过期时间命令的原子性），如果返回 true 说明拿到了锁，false 则表示没有拿到锁。<br>使用 redisson，redisson 可以控制锁的失效时间和等待时间，执行过程中，会引入一个看门狗机制，每个一段时间会检查业务是否还持有锁，还有锁就给这把锁延长失效时间，没有锁就释放锁。一个客户持有锁的时候，另外的客户进来不会立刻拒绝而是会自旋等待，提高性能，锁可以重入</li>\n</ol>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><ol>\n<li>主从复制、主从同步流程<br>从机发起 replication 请求，携带 repid（数据集 Id）和 offside，主机根据从机 repid 和自己的 repid 是否一致选择全量同步还是增量同步，全量同步时，fork 子线程执行 bgsave 生成 RDB 文件，传输到从机，从机清空数据，加载 RDB，主机生成 RDB 文件时若有新的操作，会将操作加载到一个日志文件，发送 RDB 后再发送日志文件，保证数据的一致性，增量同步时，</li>\n<li>哨兵模式、集群脑裂<br>使用哨兵集群对集群进行监控，发现主节点下线后后，从从节点中选举新的主节点，并通知客户端要往新的主节点写。<br>集群脑裂是指因为网络等原因哨兵发现主节点下线，从从机中选举新主节点，但实际主节点并没有下线，客户端仍旧在主节点写入数据，后续网络恢复正常后，旧的主节点加入集群会变成从节点，会删除已有的所有数据，导致客户端后续写入内容的丢失。</li>\n<li>分片集群、数据读写规则<br>Redis 有数据分片！！！<br>在该模式下，每个数据节点都是含有主从节点的集群，哈希槽，设置 key 时，更具 key 的 hash 值计算出对应的数据节点位置，并且自动路由到对应的数据节点主节点</li>\n</ol>\n<h1 id=\"二、面试题\"><a href=\"#二、面试题\" class=\"headerlink\" title=\"二、面试题\"></a>二、面试题</h1><p>1.<br>2. docker run –name redis -p 6379:6379 -v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;data&#x2F;:&#x2F;data&#x2F; -v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;log&#x2F;redis-server.log:&#x2F;log&#x2F;redis-server.log -d redis:7.2.2 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf<br>3. docker run –name redis -p 6379:6379 -d redis:7.2.2</p>\n","text":"一、内容整理缓存1. 缓存穿透有大量的请求访问不存在的 key，首先访问 redis，发现不存在当前 key 后 后再访问数据库，因为并不存在这条数据，当前查询...","permalink":"/post/redis","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86\"><span class=\"toc-text\">一、内容整理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">1. 缓存穿透</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\"><span class=\"toc-text\">1. 缓存击穿</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">2. 缓存雪崩</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">3. 双写一致性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">4. 持久化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">5. 数据过期策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">6. 数据淘汰策略</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">分布式锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">主从复制</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">二、面试题</span></a></li></ol>","author":{"name":"孙冬冬","slug":"blog-author","avatar":"/image/avatar.jpg","link":"/","description":"哈哈哈","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"mysql","uid":"723f0bc187c0d9e9f528c9cd6627a1c3","slug":"mysql","date":"2023-12-07T16:34:56.000Z","updated":"2023-12-08T01:33:08.589Z","comments":true,"path":"api/articles/mysql.json","keywords":null,"cover":null,"text":"一、内容整理优化1. 如何定位慢查询使用 skywalking 等工具，追踪分析接口的执行时长，使用 mysql 的慢查询日志 2. sql 语句执行的很慢，如...","permalink":"/post/mysql","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"孙冬冬","slug":"blog-author","avatar":"/image/avatar.jpg","link":"/","description":"哈哈哈","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"并发编程","uid":"be447ed25be14672c8ade5d39be9da07","slug":"并发编程","date":"2023-12-07T16:34:56.000Z","updated":"2023-12-08T01:33:08.841Z","comments":true,"path":"api/articles/并发编程.json","keywords":null,"cover":null,"text":"一、内容整理多线程基础线程和进程的区别？当系统从磁盘中将硬盘中的某个程序代码到内存，就开启了一个进程，一个进程可以有多个线程，线程由一条一条的指令组成 进程是运...","permalink":"/post/并发编程","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"孙冬冬","slug":"blog-author","avatar":"/image/avatar.jpg","link":"/","description":"哈哈哈","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}