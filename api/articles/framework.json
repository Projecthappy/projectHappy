{"title":"框架","uid":"71abd5ae262d1609d9544498b5f6da4f","slug":"framework","date":"2023-12-07T16:34:56.000Z","updated":"2023-12-08T01:33:08.241Z","comments":true,"path":"api/articles/framework.json","keywords":null,"cover":null,"content":"<h1 id=\"一、内容整理\"><a href=\"#一、内容整理\" class=\"headerlink\" title=\"一、内容整理\"></a>一、内容整理</h1><h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><h4 id=\"1-单例-bean-线程安全\"><a href=\"#1-单例-bean-线程安全\" class=\"headerlink\" title=\"1. 单例 bean 线程安全\"></a>1. 单例 bean 线程安全</h4><p>单例 bean 不是线程安全的</p>\n<h4 id=\"2-Spring-AOP\"><a href=\"#2-Spring-AOP\" class=\"headerlink\" title=\"2. Spring-AOP\"></a>2. Spring-AOP</h4><p>面向切面编程，可以增强某些类的功能，其中需要设置切面，比如设置加了注解的类方法、某个包下的类，抛出某些异常的类等，另外可以设置环绕或者前置后置等方法</p>\n<h4 id=\"3-事务失效的场景\"><a href=\"#3-事务失效的场景\" class=\"headerlink\" title=\"3. 事务失效的场景\"></a>3. 事务失效的场景</h4><ul>\n<li>方法中存在 trycatch，异常已经被内部捕获处理，可以在处理异常时再向外抛出</li>\n<li>方法抛出了检查异常，再注解中加入 <code>rollbackFor = Exception.class</code> 让事务根据所有的异常回滚</li>\n<li>方法不是 public</li>\n</ul>\n<h4 id=\"4-bean-的生命周期\"><a href=\"#4-bean-的生命周期\" class=\"headerlink\" title=\"4. bean 的生命周期\"></a>4. bean 的生命周期</h4><ul>\n<li>构造函数创建 bean</li>\n<li>注入相关依赖</li>\n<li>处理 Aware 接口，bean 实现了 Aware 接口就会重写方法执行</li>\n<li>执行后置处理器 BeanPostProcessor 的前置</li>\n<li>执行初始化方法，比如加了 PostContruct 注解的方法</li>\n<li>执行后置处理器 BeanPostProcessor 的后置，通常会对类进行增强</li>\n<li>销毁</li>\n</ul>\n<h4 id=\"5-bean-的循环依赖\"><a href=\"#5-bean-的循环依赖\" class=\"headerlink\" title=\"5. bean 的循环依赖\"></a>5. bean 的循环依赖</h4><p>比如 A 中注入了 B，B 中注入了 A<br>spring 能为我们解决大多数的循环依赖问题，因为 spring 中存在三个保存 bean 的区域，第一个是单例池，是已经初始化完成的类，第二个保存的是早期的 bean，第三个是保存类工厂</p>\n<ul>\n<li>先实例 A 对象，同时会创建 ObjectFactory 对象存入三级缓存 singletonFactories</li>\n<li>A 在初始化的时候需要 B 对象，这个走 B 的创建的逻辑</li>\n<li>B 实例化完成，也会创建 ObjectFactory 对象存入三级缓存 singletonFactories</li>\n<li>B 需要注入 A，通过三级缓存中获取 ObjectFactory 来生成一个 A 的对象同时存入二级缓存，这个是有两种情况，一个是可能是 A 的普通对象，另外一个是 A 的代理对象，都可以让 ObjectFactory 来生产对应的对象，这也是三级缓存的关键</li>\n<li>B 通过从通过二级缓存 earlySingletonObjects 获得到 A 的对象后可以正常注入，B 创建成功，存入一级缓存 singletonObjects</li>\n<li>回到 A 对象初始化，因为 B 对象已经创建完成，则可以直接注入 B，A 创建成功存入一次缓存 singletonObjects</li>\n<li>二级缓存中的临时对象 A 清除</li>\n</ul>\n<p>spring 无法解决构造方法中的循环引用，可以再构造方法中加入@Lazy 注解等到需要用到依赖类的时候再创建依赖类</p>\n<h2 id=\"Springmvc-执行流程\"><a href=\"#Springmvc-执行流程\" class=\"headerlink\" title=\"Springmvc-执行流程\"></a>Springmvc-执行流程</h2><ul>\n<li>请求进来后进入 DispatcherServlet</li>\n<li>DispatcherServlet 调用 HandlerMapper，Handler 根据路径找到对应的处理器，如果有过滤器也一起打包返回给 DispatcherServlet</li>\n<li>DispatcherServlet 再调用 HandlerHandlerAdapter，HandlerHandlerAdapter 负责处理参数和返回值，如果是纯接口将执行的结果转换并且返回，如果是模板，则将结果返回给 DispatcherServlet，之后再由视图解析器解析成 html 返回</li>\n</ul>\n<h2 id=\"Springboot-自动配置原理\"><a href=\"#Springboot-自动配置原理\" class=\"headerlink\" title=\"Springboot-自动配置原理\"></a>Springboot-自动配置原理</h2><p><code>@SpringBootApplication</code> 注解中包含 <code>@EnableAutoConfiguration</code> 、<code>@SpringBootConfigration</code> 和 <code>@ComponentScan</code>，关键在于 <code>@EnableAutoConfiguration</code>，该注解通过 <code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的 Jar 包的的 classpath 路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。</p>\n<p>在这些配置类中所定义的 Bean 会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到 Spring 容器中。</p>\n<p>一般条件判断会有像 <code>@ConditionalOnClass</code>这样的注解，判断是否有对应的 class 文件，如果有则加载该类，把这个配置类的所有的 Bean 放入 spring 容器中使用。</p>\n<h2 id=\"spring-框架常见的注解（spring、springmvc、springboot）\"><a href=\"#spring-框架常见的注解（spring、springmvc、springboot）\" class=\"headerlink\" title=\"spring 框架常见的注解（spring、springmvc、springboot）\"></a>spring 框架常见的注解（spring、springmvc、springboot）</h2><ul>\n<li>Spring<ul>\n<li>配置：@Configuration、@ComponentScan、@Bean</li>\n<li>依赖注入：@Autowired、@Qualifier、@Resourse</li>\n<li>声明 bean：@Component、@Service、@Repository、@Controller</li>\n<li>aop：@Aspect、@Before、@After、@Around、@Pointcut</li>\n</ul>\n</li>\n<li>SpringMVC：@RequestMapping、@RequestBody、@RequestParam、@PathViriable</li>\n<li>SpringBoot：@SpringBootApplication</li>\n</ul>\n<h2 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h2><h4 id=\"1-执行流程\"><a href=\"#1-执行流程\" class=\"headerlink\" title=\"1. 执行流程\"></a>1. 执行流程</h4><ul>\n<li>读取配置文件</li>\n<li>创建 <code>SqlSessionFactory</code></li>\n<li>使用 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code></li>\n<li>创建 <code>Excutor</code></li>\n<li>在 <code>Excutor</code> 中执行，其中包含 <code>MappedStatement</code> 保存了映射信息</li>\n<li>将 java 对象转化成数据库类型</li>\n<li>之后执行</li>\n<li>将类型转化成 java 对象并返回</li>\n</ul>\n<h4 id=\"2-延迟加载使用及原理\"><a href=\"#2-延迟加载使用及原理\" class=\"headerlink\" title=\"2. 延迟加载使用及原理\"></a>2. 延迟加载使用及原理</h4><p>在一个对象中存在其他的对象，比如用户实体中存在订单实体，xml 文件中查找用户的订单也是单独的 sql 语句，此时可以设置查找订单的语句为延迟加载，只有访问用户实体中的订单时才会从数据库中查找，延迟加载在底层主要使用的 CGLIB 动态代理完成的</p>\n<ul>\n<li>使用 CGLIB 创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的 mapper</li>\n<li>当调用目标方法时，进入拦截器 invoke 方法，发现目标方法是 null 值，再执行 sql 查询</li>\n<li>获取数据以后，调用 set 方法设置属性值，再继续查询目标方法，就有值了</li>\n</ul>\n<h4 id=\"3-一级、二级缓存\"><a href=\"#3-一级、二级缓存\" class=\"headerlink\" title=\"3. 一级、二级缓存\"></a>3. 一级、二级缓存</h4><h1 id=\"二、面试题\"><a href=\"#二、面试题\" class=\"headerlink\" title=\"二、面试题\"></a>二、面试题</h1>","text":"一、内容整理Spring1. 单例 bean 线程安全单例 bean 不是线程安全的 2. Spring-AOP面向切面编程，可以增强某些类的功能，其中需要设置...","permalink":"/post/framework","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86\"><span class=\"toc-text\">一、内容整理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring\"><span class=\"toc-text\">Spring</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%BE%8B-bean-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">1. 单例 bean 线程安全</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Spring-AOP\"><span class=\"toc-text\">2. Spring-AOP</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">3. 事务失效的场景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">4. bean 的生命周期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">5. bean 的循环依赖</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Springmvc-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Springmvc-执行流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Springboot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Springboot-自动配置原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#spring-%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E8%A7%A3%EF%BC%88spring%E3%80%81springmvc%E3%80%81springboot%EF%BC%89\"><span class=\"toc-text\">spring 框架常见的注解（spring、springmvc、springboot）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#MyBatis\"><span class=\"toc-text\">MyBatis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1. 执行流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2. 延迟加载使用及原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3. 一级、二级缓存</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">二、面试题</span></a></li></ol>","author":{"name":"孙冬冬","slug":"blog-author","avatar":"/image/avatar.jpg","link":"/","description":"哈哈哈","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"集合类","uid":"3d7e70cb4fa6869d52e41f2f04e3c805","slug":"collection","date":"2023-12-07T16:34:56.000Z","updated":"2023-12-08T01:33:08.237Z","comments":true,"path":"api/articles/collection.json","keywords":null,"cover":null,"text":"一、内容整理ArrayList底层原理及构造函数相关ArrayList 底层维护一个数组 elementData，共有三个构造函数 无参构造：将一个空数组赋值给...","permalink":"/post/collection","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"孙冬冬","slug":"blog-author","avatar":"/image/avatar.jpg","link":"/","description":"哈哈哈","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"mysql","uid":"723f0bc187c0d9e9f528c9cd6627a1c3","slug":"mysql","date":"2023-12-07T16:34:56.000Z","updated":"2023-12-08T01:33:08.589Z","comments":true,"path":"api/articles/mysql.json","keywords":null,"cover":null,"text":"一、内容整理优化1. 如何定位慢查询使用 skywalking 等工具，追踪分析接口的执行时长，使用 mysql 的慢查询日志 2. sql 语句执行的很慢，如...","permalink":"/post/mysql","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"孙冬冬","slug":"blog-author","avatar":"/image/avatar.jpg","link":"/","description":"哈哈哈","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}