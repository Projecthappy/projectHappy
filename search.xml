<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>金融大数据学习笔记</title>
      <link href="//post/FinancialBigData.html"/>
      <url>//post/FinancialBigData.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h3 id="大数据-2001-孙啸冬"><a href="#大数据-2001-孙啸冬" class="headerlink" title="大数据 2001 孙啸冬"></a>大数据 2001 孙啸冬</h3><ul><li>1.爬取数据<ul><li>(1) 爬取时以股票代码作为 URL 中的参数传入，但遇到没有当前股票代码时 DOM 树的结构和正常的不一样，导致运行报错<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：在爬取前先用request库中的get方法获取URL的状态码，状态码为<span class="number">200</span>时再继续</span><br></pre></td></tr></table></figure></li><li>(2) 爬取的页面中的数据是通过 js 渲染的，一开始爬取的发现表格只有表头没有内容<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解决方法：用HTML_Session库</span><br><span class="line">//创建HTMLSession对象</span><br><span class="line">session = HTMLSession()</span><br><span class="line">//session设置URL</span><br><span class="line">first_page = session.get(url)</span><br><span class="line">//渲染<span class="number">0.5</span>s</span><br><span class="line">first_page.html.render(sleep=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></li><li>(3) 在爬取东方财富网中的数据时，每爬几个就会出现连接被断开的情况，寻找解决方法时想到了用 PowerAutomate 来自动化运行，流程如下图所示：当 vscode 运行窗口出现报错时将 Ctrl+Shift+F5 发送到 vscode 窗口重新运行<br><img src="/image/FinancialBigData/1680161235760.png" alt="1680161235760"></li><li>(4) 通过 <code>tushare</code>的 api 获取数据，将股票代码依次传入 api，在这个过程中碰到了一个问题是判断有没有返回的数据，使用 <code>result==None</code>的话，返回正常的 <code>DataFrame</code>的时候报错说不支持这样的操作，建议用 <code>empty</code>方法判断是否为空，但是没有找到的画返回的又是 <code>None</code>，最后用 <code>isinstance</code>方法解决，返回对象是否是某类示例的 boolean 值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(tmp, pd.DataFrame)</span><br></pre></td></tr></table></figure></li></ul></li><li>2.处理 JSON 数据<br>JSON 中的列表可以用列表表示，对象则可以用字典来表示，本次使用中最后直接把字典传入 <code>json.dump</code>函数中即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;result.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">result = &#123;date: date <span class="keyword">for</span> date <span class="keyword">in</span> dates[<span class="number">1</span>:-<span class="number">1</span>]&#125;</span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> dates[<span class="number">1</span>:-<span class="number">1</span>]:</span><br><span class="line">    b = a.get_group(date)</span><br><span class="line">    s = []</span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> index, i <span class="keyword">in</span> b[b.<span class="built_in">type</span> == <span class="string">&#x27;深市&#x27;</span>].iterrows():</span><br><span class="line">        s.append([i[<span class="string">&quot;成交量&quot;</span>], i[<span class="string">&quot;净流出&quot;</span>], i[<span class="string">&#x27;code&#x27;</span>],  i[<span class="string">&#x27;name&#x27;</span>], <span class="string">&#x27;深市&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> index, i <span class="keyword">in</span> b[b.<span class="built_in">type</span> == <span class="string">&#x27;沪市&#x27;</span>].iterrows():</span><br><span class="line">        h.append([i[<span class="string">&quot;成交量&quot;</span>], i[<span class="string">&quot;净流出&quot;</span>], i[<span class="string">&#x27;code&#x27;</span>],  i[<span class="string">&#x27;name&#x27;</span>], <span class="string">&#x27;沪市&#x27;</span>])<span class="number">1</span></span><br><span class="line">    result[date] = &#123;<span class="string">&quot;S&quot;</span>: s, <span class="string">&quot;H&quot;</span>: h&#125;</span><br><span class="line">json.dump(result, f, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li>3.vue 中的问题<ul><li>(1) 动态图定时器<br>vue 中主要问题在最后动态的散点图中，我是想实现一个点击暂定，点击播放继续播放的效果，理想的实现方式是开始播放时创建定时器，点击停止时销毁定时器，根据文档，在 <code>setOption</code>方法将图挂载到 DOM 后就设置定时器，这样的话第一次有效，问题是每次播放后都会再创建一个定时器，定时器中是否更改数据是根据绑定的 <code>playing</code>决定的，如果 <code>playing==true</code>才更改数据，从而使图表会有根据时间动态播放的效果。于是和往常一样在组件中定义一个变量 <code>interval</code>，在挂在后调用初始化方法，在初始化时创建定时器并将值赋给 <code>interval</code>，后面根据 <code>playing</code>属性的改变创建和销毁定时器，但在实际中发现会有多个定时器同时在工作，多次点击日历后，会出现多个定时器以相隔很短的时间到达设定时间，散点图会出现抽风的情况，目前还未能解决。</li><li>(2) 图表展示过后再回到前面的图表，控制台会有警告说当前画图的元素已经在 DOM 树上了，可是我看了下也没有在，只存在当前图标元素，可能和 UI 框架切换标签的逻辑有关，目前也还没有解决。</li></ul></li><li>4.非技术问题<ul><li>(1)审题不清：一开始没有看仔细导致后面发现还有缺的数据</li><li>(2)沟通问题：爬数据和处理数据没有沟通好，导致后面字段不能很好理解</li><li>(3)规划问题：分配好工作后大家都是按照自己的那部分切入，往往是遇到问题了再去解决，很多时候就只能放弃一些效果或者做了无用功，应该一开始就有大致的规划，需要哪些数据，画什么图，要怎样的效果，大家商量一些，有个较为细致的工作内容后再开始工作。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记</title>
      <link href="//post/python.html"/>
      <url>//post/python.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h3 id="大数据-2001-孙啸冬"><a href="#大数据-2001-孙啸冬" class="headerlink" title="大数据 2001 孙啸冬"></a>大数据 2001 孙啸冬</h3><ul><li>1.DataFrame 类读取一列的方式为 <code>dataFrame[‘列名’]</code></li><li>2.DataFrame 类中一列为 Series 类</li><li>3.将字符串转为时间对象为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strptime(字符串,<span class="string">&quot;%a, %d %b %Y %H:%M:%S GMT&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>4.时间对象转换为时间戳：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.mktime(struct_time)</span><br></pre></td></tr></table></figure><ul><li>5.遍历 DataFrame 时可以用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> dataFrame.iterrows():</span><br></pre></td></tr></table></figure><ul><li>6.解析 JSON 方式为 <code>json.loads(Str)</code></li><li>7.将 Series 中每项都进行处理可以用 map，例如把数据中作者那列的字符串用空格分隔并转化为列表：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataRaw[<span class="string">&#x27;authors&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: np.array(x.split(<span class="string">&#x27;,&#x27;</span>)))</span><br></pre></td></tr></table></figure><ul><li>8.选取 DataFrame 中的多列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataRaw[[<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span><span class="string">&#x27;versionsCount&#x27;</span>, <span class="string">&#x27;diff&#x27;</span>,<span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;update_date&#x27;</span>]]</span><br></pre></td></tr></table></figure><ul><li>9.选取 DataFrame 中符合一定条件的行，例如选取 id 列中专业符合正则表达式的行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataRaw[<span class="string">&#x27;id&#x27;</span>][dataRaw.categories.<span class="built_in">str</span>.contains(<span class="string">&#x27;math.[A-Z]+&#x27;</span>)]</span><br></pre></td></tr></table></figure><ul><li>10.画图时显示调用 <code>plt.show()</code>即可不显示相关文字</li><li>11.画图时设置 x 轴标签的大小和旋转角度可以用以下方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">32</span>), labels=tmp[<span class="string">&#x27;type&#x27;</span>], rotation=<span class="number">43</span>, fontsize=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><ul><li>12.对 Series 统计可以用以下方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataRaw[<span class="string">&#x27;update_date&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure><ul><li>13.对 Series 排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataRaw[<span class="string">&#x27;update_date&#x27;</span>].sort_index()</span><br></pre></td></tr></table></figure><ul><li>14.在画时间序列图的时候发现 x 轴时这一整年的刻度，全部挤在一起看着非常难受，百度后发现以下方式更改子图的刻度密度，缺点是上面会多出一张多余的空白子图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(rotation=<span class="number">43</span>, fontsize=<span class="number">8</span>)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(dataRaw[<span class="string">&#x27;update_date&#x27;</span>].value_counts().sort_index())</span><br><span class="line">ax.xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">20</span>))</span><br><span class="line">plt.axis()</span><br><span class="line">plt.xticks(rotation=<span class="number">43</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>15.画词云图的方式：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, ImageColorGenerator</span><br><span class="line"><span class="comment"># 需要绘制的目标字符串</span></span><br><span class="line">string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 停止词</span></span><br><span class="line">stopword = [<span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;with&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;by&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;to&#x27;</span>]</span><br><span class="line"><span class="comment"># 读取文件设置词云图的底图</span></span><br><span class="line">d = path.dirname(__file__) <span class="keyword">if</span> <span class="string">&quot;__file__&quot;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">else</span> os.getcwd()</span><br><span class="line">alice_mask = np.array(Image.<span class="built_in">open</span>(path.join(d, <span class="string">&quot;alice_mask.png&quot;</span>)))</span><br><span class="line"><span class="comment"># 用相关属性构造WordCloud对象</span></span><br><span class="line">wc = WordCloud(</span><br><span class="line">    background_color=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">    width=<span class="number">1000</span>,</span><br><span class="line">    height=<span class="number">800</span>,</span><br><span class="line">    mask=alice_mask,</span><br><span class="line">    stopwords=stopword</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 生成每个词出现的频率</span></span><br><span class="line">wc.generate_from_text(string)</span><br><span class="line"><span class="comment"># 将词的颜色设置为底图位置上对应的颜色</span></span><br><span class="line">wc.recolor(color_func=ImageColorGenerator(alice_mask))</span><br><span class="line"><span class="comment"># 绘制图片</span></span><br><span class="line">wc.to_image()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记录SpringSecurity的一次实践</title>
      <link href="//post/%E8%AE%B0%E5%BD%95SpringSecurity%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5.html"/>
      <url>//post/%E8%AE%B0%E5%BD%95SpringSecurity%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;在项目中需要有用户和管理员登录的功能，用户登陆后观看视频记录观看时长，起先那做的真的时太潦草了完全没有意识，user 一张表，admin 一张表，然后不同的 RequestMapping，后来猛然惊醒，那用户不是可以在不同地方一起登录，一起看视频刷多倍的时长了么，这可不行啊，后来百度了一大圈，最后决定还是用 springsecurity，其实也不是很确定用哪个，但是就感觉它主流一点?</p><p>&ensp;&ensp;一开始看别人的博客的时候都是一头雾水，这怎么怎么就可以了，很少有对每个部分有详细的解释的，后来看了松哥的教程才渐渐的理解，链接：<a href="http://www.javaboy.org/springsecurity/">江南一点雨</a>，这篇博客也是看了松哥文章后的一次总结。</p><hr><h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p>SpringSecurity 是一个权限管理框架，包括验证用户的密码是否正确，用户的角色是普通用户还是管理员，某项操作是否得到授权等，框架的作用就是让我们少些代码少配置，缺点就是对于初学者来说就一开始比较难上手，在 springboot 中，它可以很方便和其他部分结合，只需要引入依赖就可以保护所有的接口。我们操作的主要是三个部分</p><ul><li><ol><li>实体类 User，它就是 SpringSecurity 给我们定义的实体类<br><img src="/image/%E8%AE%B0%E5%BD%95SpringSecurity%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/1678377525493.png" alt="1678377525493"><br>从源码中我们可以看到它实现了 UserDetails 接口，但是他这里实例变量很多，我们可以自己创建实体类并实现 UserDetails 接口</li></ol></li><li><ol start="2"><li>UserDetailsService 它是用来获取用户信息，返回 UserDetails 类，我们也可以创建一个类并实现 UserDetailsService 来自定义返回的内容，例如我在项目中的实现：<br><img src="/image/%E8%AE%B0%E5%BD%95SpringSecurity%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/1678377576565.png" alt="1678377576565"><br>在数据库中查找是否有对应 userId 的用户没有就抛出 UsernameNotFound 异常，然后在授权中加入用户的角色，最后返回 userBean。</li></ol></li><li>3.WebSecurityConfig 配置类</li></ul><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><p>在 pom.xml 中加入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入依赖后我们可以先直接运行试一下</p><h2 id="2-读入数据"><a href="#2-读入数据" class="headerlink" title="2.读入数据"></a>2.读入数据</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="//post/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html"/>
      <url>//post/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h4 id="常见组件有哪些"><a href="#常见组件有哪些" class="headerlink" title="常见组件有哪些"></a>常见组件有哪些</h4><ul><li>注册中心：nacos</li><li>负载均衡：ribben</li><li>远程调用：feign</li><li>服务熔断降级：sentinel</li><li>网关：gateway</li></ul><h4 id="服务注册和发现是什么意思？"><a href="#服务注册和发现是什么意思？" class="headerlink" title="服务注册和发现是什么意思？"></a>服务注册和发现是什么意思？</h4><p>服务将自己的服务名和 ip 端口号信息发送到注册中心，注册中心保存这些信息并且定时发送心跳信息，判断服务的存活状态<br>服务发现是服务和注册中心会推送和拉取服务信息，发起远程调用时根据负载均衡策略向目标服务发起请求</p><h4 id="注册中心-nacos"><a href="#注册中心-nacos" class="headerlink" title="注册中心 nacos"></a>注册中心 nacos</h4><p>nacos同时支持配置中心，集群默认采用AP模式</p><h4 id="ribbon-负载均衡，负载均衡策略，自定义负载均衡"><a href="#ribbon-负载均衡，负载均衡策略，自定义负载均衡" class="headerlink" title="ribbon 负载均衡，负载均衡策略，自定义负载均衡"></a>ribbon 负载均衡，负载均衡策略，自定义负载均衡</h4><p>feign中已经集成了ribbon，发起调用时，会先从注册中心拉去服务的地址，按照负载均衡策略选择一个地址发送<br>负载均衡有轮询，随机，权重和地域的方式<br>可以通过实现IRule接口自定义，这是全局的负载均衡策略<br>也可以通过再配置文件中配置调用每个服务的负载均衡策略</p><h4 id="服务雪崩、熔断降级"><a href="#服务雪崩、熔断降级" class="headerlink" title="服务雪崩、熔断降级"></a>服务雪崩、熔断降级</h4><p>服务雪崩是指服务的调用链路较长时，后面的服务发生了阻塞等问题，导致整个服务链路的不可用<br>可以使用服务熔断和服务降级的方式避免<br>服务降级：当调用的服务出现异常时的策略<br>服务熔断：当对服务的多次请求出现失败时，会触发熔断机制</p><h4 id="微服务的监控-skywalking"><a href="#微服务的监控-skywalking" class="headerlink" title="微服务的监控-skywalking"></a>微服务的监控-skywalking</h4><p>可以监控接口服务的状态，可以看到哪些服务和结构速度较慢，可以进行针对性的优化</p><h4 id="微服务限流（漏桶算法、令牌桶算法）"><a href="#微服务限流（漏桶算法、令牌桶算法）" class="headerlink" title="微服务限流（漏桶算法、令牌桶算法）"></a>微服务限流（漏桶算法、令牌桶算法）</h4><h4 id="分布式系统理论-CAP-和-BASE"><a href="#分布式系统理论-CAP-和-BASE" class="headerlink" title="分布式系统理论-CAP 和 BASE"></a>分布式系统理论-CAP 和 BASE</h4><p>CAP是分布式项目的一个理论，包括一致性，可用性，分区容错性</p><p>对分布式系统来说分区容错性是必须的，另外在一致性和可用性中只能二选一</p><p>BASE是CAP中AP的延申，主要思想是采取一些措施，使得数据达到最终的一致性。</p><h4 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h4><p>主要是使用MQ实现的分布式事务，对数据的即时性要求没有那么高，数据是最终一致性的</p><h4 id="分布式服务的接口幂等性如何设计"><a href="#分布式服务的接口幂等性如何设计" class="headerlink" title="分布式服务的接口幂等性如何设计"></a>分布式服务的接口幂等性如何设计</h4><p>使用token的方式，比如在打开订单页面的时候后端返回一个toke给前端，前端提交订单信息时携带token，后端检查token是否存在，存在就往下执行，然后删除token</p><h4 id="你们项目中使用了什么分布式任务调度-xxl-job"><a href="#你们项目中使用了什么分布式任务调度-xxl-job" class="headerlink" title="你们项目中使用了什么分布式任务调度-xxl-job"></a>你们项目中使用了什么分布式任务调度-xxl-job</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="//post/JVM.html"/>
      <url>//post/JVM.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h4 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h4><p>类加载器是将 class 文件加载到 jvm 中，jvm 中有四个类加载器</p><ul><li>启动类加载器：由 C++编写，加载 java 的核心类</li><li>扩展类加载器：加载 java 的扩展类</li><li>应用程序加载器：加载 classPath 中的类，也就是用户自己编写的类</li><li>自定义类加载器：用户自定义</li></ul><h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p>加载一个类时如果类有上级类加载器，则将类的加载委托给上级，如果上级类加载器不能加载这个类，就将这个类的请求向下传递，让下级的类加载器加载</p><p>原因：</p><ul><li>确保 JVM 中类的唯一性，防止重复加载</li><li>保证类库 API 的安全性</li></ul><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ul><li>加载：将类的字节码加载成 java 类模型，创建这个类的 Class 对象</li><li>验证：检查这个类是否符合 JVM 规范</li><li>准备：为static修饰的变量赋初始值，static final的直接赋值</li><li>解析：将类中的符号引用转换为直接引用</li><li>初始化：为类变量赋值，执行静态代码块</li><li>使用：从main方法中开始执行</li><li>销毁：销毁Class对象</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity6.0.1中角色继承无效的问题</title>
      <link href="//post/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
      <url>//post/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p>&ensp;&ensp;我在 SpringSecurity 中做了不少的实验，但总感觉对这个框架还是有点模糊，最近在复习 SpringSecurity，进行到角色继承时，发现角色继承并没有起作用，折腾了很久最后在 SpringSecurity 的 issue 中找到了解决方法，主要问题就是 6.0.1 的版本还没有很好地兼容 RoleHierarchy 这个 Bean。</p><h1 id="二、通常做法"><a href="#二、通常做法" class="headerlink" title="二、通常做法"></a>二、通常做法</h1><p>&ensp;&ensp;通常我们做角色继承只需要自定义注入一个 <code>RoleHierarchy</code> 的 Bean 就可以了，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">static</span> RoleHierarchy <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RoleHierarchyImpl</span> <span class="variable">hierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">        hierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> hierarchy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="三、试验"><a href="#三、试验" class="headerlink" title="三、试验"></a>三、试验</h1><p>&ensp;&ensp;准备三个接口，其中 <code>getAll</code> 不设置访问权限，<code>getUser</code> 只允许有 User 权限的用户访问，<code>getAdmin</code> 只允许有 Admin 权限的用户访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getAll&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">(<span class="meta">@RequestParam(&quot;msg&quot;)</span> String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg + <span class="string">&quot; ALL&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam(&quot;msg&quot;)</span> String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg + <span class="string">&quot; USER&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getAdmin&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAdmin</span><span class="params">(<span class="meta">@RequestParam(&quot;msg&quot;)</span> String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msg + <span class="string">&quot; ADMIN&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后向登录接口发送请求，在这里用户 1111 的角色是管理员，111 则是普通用户，这两个账号是在保存再数据库中的，登录成功后返回用户名</p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678157532410.png#pic_center" alt="1678157532410"></p><p>之后访问 <code>getAll</code></p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678157741520.png" alt="1678157741520"></p><p>访问成功,再访问 <code>getAdmin</code></p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678157776037.png" alt="1678157776037"><br>也能访问到，最后再访问 <code>getUser</code> 看看角色继承是否有效<br><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678157826069.png" alt="1678157826069"></p><p>这里报 403 禁止访问了，为了探究是哪出的问题，我们在类 <code>SecurityExpressionRoot</code> 的 <code>hasRole</code> 方法中打个断点，之后一直步入到方法 <code>hasAnyAuthorityName</code>，该方法的第一行是将方法 <code>getAuthoritySet</code> 的结果放到 <code>roleSet</code> 中，根据名字这个方法应该是获取当前用户的角色集合。</p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678158151080.png" alt="1678158151080"></p><p>步过该方法，发现这集合里面只有 ROLE*ADMIN</p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678159673712.png" alt="1678159673712"></p><p>方法 <code>hasAnyAuthorityName</code> 后面的部分则是把 <code>haseRole</code> 中的角色加上前缀 ROLE*，并判断这个角色是否在 <code>roleSet</code> 里，那这肯定是不包括的，最后返回 False，所以就访问不到这个接口了。<br>我们重新在发送一次请求到 <code>getUser</code>，步入方法 <code>getAuthoritySet</code>，</p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678159809157.png" alt="1678159809157"></p><p>其中关键的第三行可以看到就是判断当前对象的 <code>roleHierachy</code> 是否为空，不为空则将返回所有可访问权限的集合</p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678161022293.png" alt="1678161022293"></p><p>之后将权限集合转换为 <code>Set</code></p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678161087471.png" alt="1678161087471"></p><p>但在这里 <code>roleHierachy</code> 是 null 啊，what？我们配置的角色继承哪去了？</p><p>后面去翻了翻 <a href="https://docs.spring.io/spring-security/reference/6.0.1/servlet/authorization/architecture.html#authz-hierarchical-roles">SpringSecurity 的文档</a>，它给的示例是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">AccessDecisionVoter <span class="title function_">hierarchyVoter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RoleHierarchy</span> <span class="variable">hierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">    hierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_STAFF\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;ROLE_STAFF &gt; ROLE_USER\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyVoter</span>(hierarchy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这个方法写了之后依旧还是不行。。。<br>idea 也提示类 <code>AccessDecisionVoter</code> 和 <code>RoleHierarchyVoter</code> 已经弃用了，进入这两个类都提示改用 <code>AuthorizationManager</code></p><p>在 SpringSecurity 的<a href="https://github.com/spring-projects/spring-security/issues/12766">一个 issue</a> 中发现有关文档中给的示例无效的问题<br>后面的回复中有一个解决方法。</p><blockquote><p>Thanks for the report, @istoony. <code>RoleHierarchy</code> bean configuration is not fully ported over as of 6.0.x. As such, I think what should be done here is add a note about that in the documentation and then update it once completed. I’ve also added #12783 detailing what needs to be done to support <code>RoleHierarchy</code> bean configuration.<br>In the meantime, to configure <code>RoleHierarchy</code> for pre-post method security, use <code>DefaultMethodSecurityExpressionHandler</code>:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">static</span> RoleHierarchy <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RoleHierarchy</span> <span class="variable">hierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">    hierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_STAFF\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;ROLE_STAFF &gt; ROLE_USER\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;ROLE_USER &gt; ROLE_GUEST&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyVoter</span>(hierarchy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">static</span> DefaultMethodSecurityExpressionHandler <span class="title function_">methodSecurityExpressionHandler</span><span class="params">(RoleHierarchy roleHierarchy)</span> &#123;</span><br><span class="line">    <span class="type">DefaultMethodSecurityExpressionHandler</span> <span class="variable">expressionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodSecurityExpressionHandler</span>();</span><br><span class="line">    expressionHandler.setRoleHierarchy(roleHierarchy);</span><br><span class="line">    <span class="keyword">return</span> expressionHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>And to configure it for filter security, use the <code>access(AuthorizationManager)</code> method instead of <code>hasRole</code>, like so:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AuthorityAuthorizationManager&lt;RequestAuthorizationContext&gt; hasRoleUser =</span><br><span class="line">    AuthorityAuthorizationManager.hasRole(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">hasRoleUser.setRoleHierarchy(roleHierarchy);</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">    .authorizeHttpRequests((authorize) -&gt; authorize</span><br><span class="line">        .requestMatchers(<span class="string">&quot;/needs/user/**&quot;</span>).access(hasRoleUser)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>按照这个示例将角色继承的配置修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">static</span> RoleHierarchy <span class="title function_">roleHierarchy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RoleHierarchyImpl</span> <span class="variable">hierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleHierarchyImpl</span>();</span><br><span class="line">        hierarchy.setHierarchy(<span class="string">&quot;ROLE_ADMIN &gt; ROLE_user&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> hierarchy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">static</span> DefaultMethodSecurityExpressionHandler <span class="title function_">methodSecurityExpressionHandler</span><span class="params">(RoleHierarchy roleHierarchy)</span> &#123;</span><br><span class="line">        <span class="type">DefaultMethodSecurityExpressionHandler</span> <span class="variable">expressionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodSecurityExpressionHandler</span>();</span><br><span class="line">        expressionHandler.setRoleHierarchy(roleHierarchy);</span><br><span class="line">        <span class="keyword">return</span> expressionHandler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过测试，角色为 ADMIN 的用户都可以访问到 <code>hasRole(&quot;user&quot;)</code>的接口，并且 user 角色也还是访问不了 <code>hasRole(&quot;ADMIN&quot;)</code>的接口，角色继承生效了！</p><h1 id="通常做法无效的原因"><a href="#通常做法无效的原因" class="headerlink" title="通常做法无效的原因"></a>通常做法无效的原因</h1><p>在 6.1.0-SNAPSHOT 版本的文档中对应角色继承的位置有这么一个提示</p><p><img src="/image/SpringSecurity6.0.1%E4%B8%AD%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E6%97%A0%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/1678168778522.png" alt="1678168778522"><br><code>RoleHierarchy</code> 这个 Bean 还没有适配@EnableMethodSecurity 这个注解，需要等到这个 issues 修完。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows搭建RabbitMq集群</title>
      <link href="//post/Windows%E6%90%AD%E5%BB%BARabbitMq%E9%9B%86%E7%BE%A4.html"/>
      <url>//post/Windows%E6%90%AD%E5%BB%BARabbitMq%E9%9B%86%E7%BE%A4.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p>&ensp;&ensp;RabbitMQ 在 Linux 端的集群搭建可参考的教程很多，但 windows 端的相对较少，虽然生产环境肯定还是要在 Linux 上整的，但是本着不整好不痛快的精神，参考了好几篇博客，踩了一些坑，终于搭好了。😆😆😆</p><h1 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h1><p>集群包括一个主节点，两个从节点，以下是操作步骤</p><ol><li><p>打开 windows 命令提示符，注意不是 powershell(后续需要在这个终端设置变量)<br><img src="/image/Windows%E6%90%AD%E5%BB%BARabbitMq%E9%9B%86%E7%BE%A4/1687607312573.png" alt="1687607312573"></p></li><li><p>新建三个命令提示符，每个终端负责每个节点的环境配置和启动，在每个命令提示符中依次执行设置环境变量，启动节点的命令。<br><code>第一、三行命令中的值是端口号，第二行的值是节点名称，可以根据需求更改</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置主节点</span></span><br><span class="line"><span class="built_in">set</span> RABBITMQ_NODE_PORT=5673</span><br><span class="line"><span class="built_in">set</span> RABBITMQ_NODENAME=master</span><br><span class="line"><span class="built_in">set</span> RABBITMQ_SERVER_START_ARGS=-rabbitmq_management listener [&#123;port,15673&#125;]</span><br><span class="line">rabbitmq-server.bat</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置从1节点</span></span><br><span class="line"><span class="built_in">set</span> RABBITMQ_NODE_PORT=5674</span><br><span class="line"><span class="built_in">set</span> RABBITMQ_NODENAME=slave1</span><br><span class="line"><span class="built_in">set</span> RABBITMQ_SERVER_START_ARGS=-rabbitmq_management listener [&#123;port,15674&#125;]</span><br><span class="line">rabbitmq-server.bat</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置从2节点</span></span><br><span class="line"><span class="built_in">set</span> RABBITMQ_NODE_PORT=5675</span><br><span class="line"><span class="built_in">set</span> RABBITMQ_NODENAME=slave2</span><br><span class="line"><span class="built_in">set</span> RABBITMQ_SERVER_START_ARGS=-rabbitmq_management listener [&#123;port,15675&#125;]</span><br><span class="line">rabbitmq-server.bat</span><br></pre></td></tr></table></figure></li><li><p>新建一个终端，在终端内停止每个节点的运行并重置每个节点(防止创建集群时出现不同步等问题)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat -n master stop_app</span><br><span class="line">rabbitmqctl.bat -n master reset</span><br><span class="line"></span><br><span class="line">rabbitmqctl.bat -n slave1 stop_app</span><br><span class="line">rabbitmqctl.bat -n slave1 reset</span><br><span class="line"></span><br><span class="line">rabbitmqctl.bat -n slave2 stop_app</span><br><span class="line">rabbitmqctl.bat -n slave2 reset</span><br></pre></td></tr></table></figure></li><li><p>启动主节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat -n master start_app</span><br></pre></td></tr></table></figure></li><li><p>从节点挂载到主节点下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat -n slave1 join_cluster master@workMachine</span><br><span class="line">rabbitmqctl.bat -n slave2 join_cluster master@workMachine</span><br></pre></td></tr></table></figure></li><li><p>启动从节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl.bat -n slave1 start_app</span><br><span class="line">rabbitmqctl.bat -n slave2 start_app</span><br></pre></td></tr></table></figure></li></ol><h1 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h1><p>这时再进入主节点的控制界面就可以看到三个节点都在线了<br><img src="/image/Windows%E6%90%AD%E5%BB%BARabbitMq%E9%9B%86%E7%BE%A4/1687607211343.png" alt="1687607211343"><br>通过命令 <code>rabbitmqctl.bat cluster_status -n master</code>也可以看到三个节点的运行状况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\hahaha&gt; rabbitmqctl.bat cluster_status -n master</span><br><span class="line">Cluster status of node master@workMachine ...</span><br><span class="line">Basics</span><br><span class="line"></span><br><span class="line">Cluster name: master@workMachine</span><br><span class="line">Total CPU cores available cluster-wide: 48</span><br><span class="line"></span><br><span class="line">Disk Nodes</span><br><span class="line"></span><br><span class="line">master@workMachine</span><br><span class="line">slave1@workMachine</span><br><span class="line">slave2@workMachine</span><br><span class="line"></span><br><span class="line">Running Nodes</span><br><span class="line"></span><br><span class="line">master@workMachine</span><br><span class="line">slave1@workMachine</span><br><span class="line">slave2@workMachine</span><br><span class="line"></span><br><span class="line">Versions</span><br><span class="line"></span><br><span class="line">master@workMachine: RabbitMQ 3.12.0 on Erlang 26.0.1</span><br><span class="line">slave1@workMachine: RabbitMQ 3.12.0 on Erlang 26.0.1</span><br><span class="line">slave2@workMachine: RabbitMQ 3.12.0 on Erlang 26.0.1</span><br><span class="line"></span><br><span class="line">CPU Cores</span><br><span class="line"></span><br><span class="line">Node: master@workMachine, available CPU cores: 16</span><br><span class="line">Node: slave1@workMachine, available CPU cores: 16</span><br><span class="line">Node: slave2@workMachine, available CPU cores: 16</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合类</title>
      <link href="//post/collection.html"/>
      <url>//post/collection.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h4 id="底层原理及构造函数相关"><a href="#底层原理及构造函数相关" class="headerlink" title="底层原理及构造函数相关"></a>底层原理及构造函数相关</h4><p>ArrayList 底层维护一个数组 elementData，共有三个构造函数</p><ul><li>无参构造：将一个空数组赋值给 elementData</li><li>参数 int initialCapacity：初始化手动指定数组长度，小于 0 抛出异常，等于 0 将 elementData 赋值为空数组，大于 0 赋值为指定长度的数组</li><li>参数 Collection&lt;? extends E&gt; c：将 c 转化为数组后更具情况赋值</li></ul><p>在增加元素时，首先会判断当前数组的空间是否足够，如果不够，调用 grow 方法需要扩容为原大小的 1.5 倍，然后再将元素存储到数组中 size 的位置中</p><h4 id="如何实现数组和-List-之间的转换"><a href="#如何实现数组和-List-之间的转换" class="headerlink" title="如何实现数组和 List 之间的转换"></a>如何实现数组和 List 之间的转换</h4><p>List 转数组，调用 List 的 toArray 方法，更改数组，list 不会变，因为是将数据拷贝到数组<br>数组转 List，工具类 Arrays 的 asList 方法（注意：返回的 ArrayList 不能操作，因为返回的是 Arrays 内部的类，不是常见的那个），更改数组，list 会变，因为底层只是将数组的地址赋给了 ArrayList 中的数组</p><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><p>ArrayList 底层为数组，LinkedList 底层为链表<br>访问元素时，ArrayList 的时间复杂度为 O(1)，链表为 O(n)<br>LinkedList 在头尾增加或删除时间复杂度为 O(1)，其他部分需要遍历链表时间复杂度为 O(n)<br>ArrayList 在后面增加元素时间复杂度为 O(1)，其他部分需要时间复杂度为 O(n)</p><p>链表占用的空间会大一些，因为还需要存储两个指针</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h4 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h4><p>根据 key 计算出 hash 值得到一个索引的位置，然后将元素放置到对应的位置，如果存在元素就将元素挂载到已有元素的下方，变成一个双向链表，当链表长度大于 8，数组长度大于 64 时，会将对应索引位置的链表转换成红黑树</p><h4 id="put-方法的具体流程"><a href="#put-方法的具体流程" class="headerlink" title="put 方法的具体流程"></a>put 方法的具体流程</h4><p>首先判断当前的数组是否为空，不充足则先扩容，然后再计算 key 的索引值，再查看索引位置是否有元素，已经存在元素则比较索引位置值的 key 和插入数据的 key 是否相同，相同就直接更新，不相同判断是否为红黑树，不是红黑树那就是链表，随后遍历链表，如果存在相同的 key 则更新，遍历完还没有相同的，直接在尾部插入，判断长度是否大于 8，考虑是否需要转化成红黑树，如果是红黑树，则直接执行红黑树的插入方法，插入完成后判断++size 和四分之三数组长度的大小，大于则需要扩容</p><h4 id="HashMap-的扩容机制"><a href="#HashMap-的扩容机制" class="headerlink" title="HashMap 的扩容机制"></a>HashMap 的扩容机制</h4><p>首先判断是否大于 0，否则直接设置数组容量为 16，阈值为 12 并且新建数组，如果大于 0，则创建值为现在长度的两倍的变量作为新数组的长度，并且创建一个新数组，之后需要遍历数组，如果只有下标位置一个元素就直接放入新数组的对应位置，对应位置由索引模新数组长度计算得到，如果下标位置之后还有元素再判断是否为红黑树，是红黑树则直接添加红黑树，不是红黑树，那么说明是链表，需要遍历链表，对链表的元素做拆分的操作，链表元素的 hash 值模老数组的长度，等于 0 则直接添加到新数组相同下标，其他情况添加到新数组中下标为下标值加上老数组的长度</p><h4 id="HashMap-的寻址算法和数组长度为什么是-2-的-n-次幂"><a href="#HashMap-的寻址算法和数组长度为什么是-2-的-n-次幂" class="headerlink" title="HashMap 的寻址算法和数组长度为什么是 2 的 n 次幂"></a>HashMap 的寻址算法和数组长度为什么是 2 的 n 次幂</h4><p>因为一个值模 2 的 n 次幂可以转换成（值-1）&amp;2 的 n 次幂<br>便于扩容时对 hash 值进行计算</p><h1 id="二、面试题"><a href="#二、面试题" class="headerlink" title="二、面试题"></a>二、面试题</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>框架</title>
      <link href="//post/framework.html"/>
      <url>//post/framework.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h4 id="1-单例-bean-线程安全"><a href="#1-单例-bean-线程安全" class="headerlink" title="1. 单例 bean 线程安全"></a>1. 单例 bean 线程安全</h4><p>单例 bean 不是线程安全的</p><h4 id="2-Spring-AOP"><a href="#2-Spring-AOP" class="headerlink" title="2. Spring-AOP"></a>2. Spring-AOP</h4><p>面向切面编程，可以增强某些类的功能，其中需要设置切面，比如设置加了注解的类方法、某个包下的类，抛出某些异常的类等，另外可以设置环绕或者前置后置等方法</p><h4 id="3-事务失效的场景"><a href="#3-事务失效的场景" class="headerlink" title="3. 事务失效的场景"></a>3. 事务失效的场景</h4><ul><li>方法中存在 trycatch，异常已经被内部捕获处理，可以在处理异常时再向外抛出</li><li>方法抛出了检查异常，再注解中加入 <code>rollbackFor = Exception.class</code> 让事务根据所有的异常回滚</li><li>方法不是 public</li></ul><h4 id="4-bean-的生命周期"><a href="#4-bean-的生命周期" class="headerlink" title="4. bean 的生命周期"></a>4. bean 的生命周期</h4><ul><li>构造函数创建 bean</li><li>注入相关依赖</li><li>处理 Aware 接口，bean 实现了 Aware 接口就会重写方法执行</li><li>执行后置处理器 BeanPostProcessor 的前置</li><li>执行初始化方法，比如加了 PostContruct 注解的方法</li><li>执行后置处理器 BeanPostProcessor 的后置，通常会对类进行增强</li><li>销毁</li></ul><h4 id="5-bean-的循环依赖"><a href="#5-bean-的循环依赖" class="headerlink" title="5. bean 的循环依赖"></a>5. bean 的循环依赖</h4><p>比如 A 中注入了 B，B 中注入了 A<br>spring 能为我们解决大多数的循环依赖问题，因为 spring 中存在三个保存 bean 的区域，第一个是单例池，是已经初始化完成的类，第二个保存的是早期的 bean，第三个是保存类工厂</p><ul><li>先实例 A 对象，同时会创建 ObjectFactory 对象存入三级缓存 singletonFactories</li><li>A 在初始化的时候需要 B 对象，这个走 B 的创建的逻辑</li><li>B 实例化完成，也会创建 ObjectFactory 对象存入三级缓存 singletonFactories</li><li>B 需要注入 A，通过三级缓存中获取 ObjectFactory 来生成一个 A 的对象同时存入二级缓存，这个是有两种情况，一个是可能是 A 的普通对象，另外一个是 A 的代理对象，都可以让 ObjectFactory 来生产对应的对象，这也是三级缓存的关键</li><li>B 通过从通过二级缓存 earlySingletonObjects 获得到 A 的对象后可以正常注入，B 创建成功，存入一级缓存 singletonObjects</li><li>回到 A 对象初始化，因为 B 对象已经创建完成，则可以直接注入 B，A 创建成功存入一次缓存 singletonObjects</li><li>二级缓存中的临时对象 A 清除</li></ul><p>spring 无法解决构造方法中的循环引用，可以再构造方法中加入@Lazy 注解等到需要用到依赖类的时候再创建依赖类</p><h2 id="Springmvc-执行流程"><a href="#Springmvc-执行流程" class="headerlink" title="Springmvc-执行流程"></a>Springmvc-执行流程</h2><ul><li>请求进来后进入 DispatcherServlet</li><li>DispatcherServlet 调用 HandlerMapper，Handler 根据路径找到对应的处理器，如果有过滤器也一起打包返回给 DispatcherServlet</li><li>DispatcherServlet 再调用 HandlerHandlerAdapter，HandlerHandlerAdapter 负责处理参数和返回值，如果是纯接口将执行的结果转换并且返回，如果是模板，则将结果返回给 DispatcherServlet，之后再由视图解析器解析成 html 返回</li></ul><h2 id="Springboot-自动配置原理"><a href="#Springboot-自动配置原理" class="headerlink" title="Springboot-自动配置原理"></a>Springboot-自动配置原理</h2><p><code>@SpringBootApplication</code> 注解中包含 <code>@EnableAutoConfiguration</code> 、<code>@SpringBootConfigration</code> 和 <code>@ComponentScan</code>，关键在于 <code>@EnableAutoConfiguration</code>，该注解通过 <code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的 Jar 包的的 classpath 路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。</p><p>在这些配置类中所定义的 Bean 会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到 Spring 容器中。</p><p>一般条件判断会有像 <code>@ConditionalOnClass</code>这样的注解，判断是否有对应的 class 文件，如果有则加载该类，把这个配置类的所有的 Bean 放入 spring 容器中使用。</p><h2 id="spring-框架常见的注解（spring、springmvc、springboot）"><a href="#spring-框架常见的注解（spring、springmvc、springboot）" class="headerlink" title="spring 框架常见的注解（spring、springmvc、springboot）"></a>spring 框架常见的注解（spring、springmvc、springboot）</h2><ul><li>Spring<ul><li>配置：@Configuration、@ComponentScan、@Bean</li><li>依赖注入：@Autowired、@Qualifier、@Resourse</li><li>声明 bean：@Component、@Service、@Repository、@Controller</li><li>aop：@Aspect、@Before、@After、@Around、@Pointcut</li></ul></li><li>SpringMVC：@RequestMapping、@RequestBody、@RequestParam、@PathViriable</li><li>SpringBoot：@SpringBootApplication</li></ul><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h4 id="1-执行流程"><a href="#1-执行流程" class="headerlink" title="1. 执行流程"></a>1. 执行流程</h4><ul><li>读取配置文件</li><li>创建 <code>SqlSessionFactory</code></li><li>使用 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code></li><li>创建 <code>Excutor</code></li><li>在 <code>Excutor</code> 中执行，其中包含 <code>MappedStatement</code> 保存了映射信息</li><li>将 java 对象转化成数据库类型</li><li>之后执行</li><li>将类型转化成 java 对象并返回</li></ul><h4 id="2-延迟加载使用及原理"><a href="#2-延迟加载使用及原理" class="headerlink" title="2. 延迟加载使用及原理"></a>2. 延迟加载使用及原理</h4><p>在一个对象中存在其他的对象，比如用户实体中存在订单实体，xml 文件中查找用户的订单也是单独的 sql 语句，此时可以设置查找订单的语句为延迟加载，只有访问用户实体中的订单时才会从数据库中查找，延迟加载在底层主要使用的 CGLIB 动态代理完成的</p><ul><li>使用 CGLIB 创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的 mapper</li><li>当调用目标方法时，进入拦截器 invoke 方法，发现目标方法是 null 值，再执行 sql 查询</li><li>获取数据以后，调用 set 方法设置属性值，再继续查询目标方法，就有值了</li></ul><h4 id="3-一级、二级缓存"><a href="#3-一级、二级缓存" class="headerlink" title="3. 一级、二级缓存"></a>3. 一级、二级缓存</h4><h1 id="二、面试题"><a href="#二、面试题" class="headerlink" title="二、面试题"></a>二、面试题</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="//post/mysql.html"/>
      <url>//post/mysql.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h4 id="1-如何定位慢查询"><a href="#1-如何定位慢查询" class="headerlink" title="1. 如何定位慢查询"></a>1. 如何定位慢查询</h4><p>使用 skywalking 等工具，追踪分析接口的执行时长，使用 mysql 的慢查询日志</p><h4 id="2-sql-语句执行的很慢，如何分析"><a href="#2-sql-语句执行的很慢，如何分析" class="headerlink" title="2. sql 语句执行的很慢，如何分析"></a>2. sql 语句执行的很慢，如何分析</h4><p>使用 explan 语句分析 sql 的执行计划，结果会展示走了哪个索引，索引长度走了多少，语句的优化建议等信息。</p><h4 id="3-索引概念及索引底层数据结构"><a href="#3-索引概念及索引底层数据结构" class="headerlink" title="3. 索引概念及索引底层数据结构"></a>3. 索引概念及索引底层数据结构</h4><p>索引是 mysql 额外维护的一些数据，用于快速查找到数据，和排序数据，底层是 B+树，和 B-树相比，B+树每个数据都储存在叶子节点，并且数据之间使用前后指针相连，形成一个双向链表，便于对数据进行范围查询，查找效率也更稳定。</p><h4 id="4-聚簇索引和非聚簇索引、回表查询"><a href="#4-聚簇索引和非聚簇索引、回表查询" class="headerlink" title="4. 聚簇索引和非聚簇索引、回表查询"></a>4. 聚簇索引和非聚簇索引、回表查询</h4><p>聚簇索引是指索引下的是一行的数据，非聚簇索引是指索引下的数据不是完整的一行，回表查询是指走了非聚集索引，但非聚集索引下的数据不完整，需要根据非聚集索引中的聚集索引再去聚集索引中找到完整的数据</p><h4 id="5-覆盖索引、超大分页优化"><a href="#5-覆盖索引、超大分页优化" class="headerlink" title="5. 覆盖索引、超大分页优化"></a>5. 覆盖索引、超大分页优化</h4><p>索引覆盖是指，走非聚集索引，非聚集索引中包含了要查找的所有字段，因此不需要再回表查询，因此我们常常将经常查找的字段设为联合索引，超大分页优化是使用子查询，在子查询中查找到主键的范围，然后再去聚簇索引中查找对应的行，提高性能。</p><h4 id="6-索引创建的原则"><a href="#6-索引创建的原则" class="headerlink" title="6. 索引创建的原则"></a>6. 索引创建的原则</h4><ul><li>很长的字段作为索引时使用前缀索引</li><li>对需要经常一起查询的数据创建联合索引</li></ul><h4 id="7-什么情况下索引会失效"><a href="#7-什么情况下索引会失效" class="headerlink" title="7. 什么情况下索引会失效"></a>7. 什么情况下索引会失效</h4><ul><li>违反最左前缀法则</li><li>索引字段出现条件右边的索引会失效</li><li>出现字符串左边的模糊匹配</li><li>在索引的字段上进行计算</li><li>字符串没有加引号</li></ul><h4 id="8-谈一谈你对-sql-优化的经验"><a href="#8-谈一谈你对-sql-优化的经验" class="headerlink" title="8. 谈一谈你对 sql 优化的经验"></a>8. 谈一谈你对 sql 优化的经验</h4><ul><li>建表时根据数据的实际情况使用适合的数据类型</li><li>如果字段定长，使用固定长度 char 类型，相比于不定长效率会更高</li><li>为经常一起查询的字段建立索引</li><li>分库分表</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h4 id="1-事务的特性"><a href="#1-事务的特性" class="headerlink" title="1. 事务的特性"></a>1. 事务的特性</h4><ul><li>A：原子性，一个事务是执行的最小单元</li><li>C：一致性，要么全都执行成功，要么全部执行失败</li><li>I：隔离性，别的事务的操作不会影响当前事务</li><li>D：持久性，事务提交后对数据的更改是永久的</li></ul><h4 id="2-并发事务问题、隔离级别"><a href="#2-并发事务问题、隔离级别" class="headerlink" title="2. 并发事务问题、隔离级别"></a>2. 并发事务问题、隔离级别</h4><p>在并发事务中存在三个问题</p><ul><li>脏读，读取到了别的事务还没有提交的事务</li><li>不可重复读，一个事务中两次读取到的同一条记录中有字段值不同</li><li>幻读，查找时不存在这条记录，插入时却发现已经存在了这条记录</li></ul><p>为了解决这三个问题，事务又有四个不同的隔离级别</p><ul><li>读未提交，脏读、不可重复读和幻读都可能出现</li><li>读已提交：只能避免脏读</li><li>可重复读：可以避免脏读和不可重复读</li><li>串行化：可以避免所有问题<br>mysql 默认的隔离级别时可重复读，这四个隔离级别中越往下数据安全性越高，但是性能越差</li></ul><h4 id="3-事务-undo-log-和-redo-log-的区别"><a href="#3-事务-undo-log-和-redo-log-的区别" class="headerlink" title="3. 事务-undo log 和 redo log 的区别"></a>3. 事务-undo log 和 redo log 的区别</h4><p>undo log 储存的是事务的回滚语句，比如事务中执行 delete，redo log 会生成 insert 语句。</p><p>redo log 储存的是数据页的物理变化，mysql 直接操作的是内存中的缓冲池中的片，按照一定的频率同步到磁盘中，但有可能出现宕机，数据未同步到磁盘，造成数据丢失的情况，undo log 就是记录这种情况下的操作，数据库恢复时，读取 undo log 恢复未同步的数据</p><h2 id="解释一下-mvcc"><a href="#解释一下-mvcc" class="headerlink" title="解释一下 mvcc"></a>解释一下 mvcc</h2><p>mvcc 是多版本并发控制，用于记录多个事务对数据的操作的版本，是的读操作和写操作没有冲突，主要由隐藏字段、undo log 和读视图组成 。</p><ul><li>隐藏字段：在每个表中mysql 会默认生成几个字段，包括了当前事务的 id，上一个版本的指针等信息。</li><li>undo log：存储版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本</li></ul><p> readView 解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务 id 判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是 rc 隔离级别，每一次执行快照读时生成 ReadView，如果是 rr 隔离级别仅在事务中第一次执行快照读时生成 ReadView，后续复用</p><h4 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h4><p>主库将 DML 和 DDL 生成 binlog 二进制文件，但不包括 selet 和 show 命令，然后从机获取主机中的 binlog，加载到从机的中间日志，从机读取中间日志，执行命令，完成同步</p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h1 id="二、面试题"><a href="#二、面试题" class="headerlink" title="二、面试题"></a>二、面试题</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="//post/redis.html"/>
      <url>//post/redis.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h4><p>有大量的请求访问不存在的 key，首先访问 redis，发现不存在当前 key 后 后再访问数据库，因为并不存在这条数据，当前查询的结果为 <code>null</code>，也不会在 redis 中建立缓存，导致所有的请求全都打在数据库上，导致数据库崩溃</p><ul><li>缓存中添加空值<br>优点：实现简单<br>缺点：造成内存资源的浪费</li><li>布隆过滤器：创建一个比较大的数组，利用比特位，通过计算 key 的多个 hash 值，将对应位的值变为 1，请求时先经过布隆过滤器，通过计算目标 key 的 hash 判断对应位置的值是否全为 1 判断是否存在，但有误判的可能：一个 key 的 hash 对应到两个不同 key 的 hash 的比特位。<br>优点：不会造成内存资源的浪费<br>缺点：增加过滤器，会降低一些性能，实现较为复杂，有一定概率会误判。</li></ul><h4 id="1-缓存击穿"><a href="#1-缓存击穿" class="headerlink" title="1. 缓存击穿"></a>1. 缓存击穿</h4><p>某个热点 key 突然失效，所有的请求都打到数据库，导致数据库的崩溃</p><ul><li>设置互斥锁：当缓存失效后，通过 setnx 设置一个互斥锁，拿到这把锁的线程去进行缓存重建<br>优点：数据一致性较强<br>缺点：性能较低，可能产生死锁问题</li><li>设置逻辑过期时间：在建立缓存时当前缓存不设置过期时间，而是加入一个逻辑过期时间，查询后直接返回值并判断比较当前时间和逻辑过期时间，如果过期，开启另一个线程进行数据的同步。<br>优点：效率较高，性能不会有明显下降<br>缺点：过期后，返回的仍旧是旧数据，数据一致性较差</li></ul><h4 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h4><p>在某个时间，大量的 key 同时失效</p><ul><li>在创建缓存时，在设置的过期时间后添加一个随机数</li></ul><h4 id="3-双写一致性"><a href="#3-双写一致性" class="headerlink" title="3. 双写一致性"></a>3. 双写一致性</h4><p>数据库和缓存数据的一致性</p><ul><li>可以接受一定延时：双删，删除缓存，更新数据库，再删除一次缓存<br>更新数据时分为先更新数据库和先删除缓存，两者都有可能产生数据的不一致<br><img src="/image/redis/1689438549264.png" alt="1689438549264"><br><img src="/image/redis/1689438479837.png" alt="1689438479837"><br>其中先删数据库的方式发生的概率要远远小于先删除缓存<br>优点：实现较为简单<br>缺点：延时的时长不好控制，有一定的概率产生脏数据，可以使用消息队列，对缓存进行更改，避免脏数据的产生（canal）</li><li>强一致性：采用的是 redisson 实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据</li></ul><h4 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h4><ul><li>RDB（内存快照）保存的是 redis 某一时刻的数据快照，主线程 fork 一个子线程，在内存空间中共享一个页表，能够访问到相同的内存，子线程完成内存快照的保存，可以通过配置 save 设置多少时间内修改多少个 key 保存快照<br>优点：数据量较小<br>缺点：发生宕机时，丢失的数据相对较多</li><li>AOF（命令）保存的是一条一条的 redis 命令，可以通过更改 appendfsync 配置保存增加命令的时间间隔，通过！！！配置将指令重排，将对同一个 key 的多次操作合并成一个，以减少数据量<br>优点：发生宕机时丢失数据相对较少<br>缺点：数据量较大</li></ul><h4 id="5-数据过期策略"><a href="#5-数据过期策略" class="headerlink" title="5. 数据过期策略"></a>5. 数据过期策略</h4><p>当到了 key 设置的过期时间后，从内存中删除 key 的策略</p><ul><li>惰性删除：到了过期时间后，不会立即删除内存中的 key 而是等到再次访问这个 key 的时候返回 <code>null</code>并从内存中删除</li><li>定期删除：按照一定的时间间隔扫描所有的 key，发现到了过期时间了再删除，该操作的时间不能超过设置的时长，超过设置时长会直接结束，等待下一轮</li></ul><h4 id="6-数据淘汰策略"><a href="#6-数据淘汰策略" class="headerlink" title="6. 数据淘汰策略"></a>6. 数据淘汰策略</h4><p>当系统无可用内存时 redis 的行为，默认设置的是直接拒绝设置 key 的请求，另外还可以设置淘汰策略，例如随机，按照访问频率等，其中有两个重要概念 LRU 和 LFU，LRU（最近最少使用）当前时间减去每个 key 最后一次访问的时间，得到每个 key 没有被访问的时长，LFU（最少频率使用）一段时间内每个 key 的访问次数</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ol><li>使用场景<br>分布式系统中一个应用部署在多台服务器上，内存不在同一个空间</li><li>分布式锁-实现原理（setnx、redisson）<br>使用 setnx 命令（实际使用 set lock 1 nx ex 10 的形式，相比 setnx 保证锁和过期时间命令的原子性），如果返回 true 说明拿到了锁，false 则表示没有拿到锁。<br>使用 redisson，redisson 可以控制锁的失效时间和等待时间，执行过程中，会引入一个看门狗机制，每个一段时间会检查业务是否还持有锁，还有锁就给这把锁延长失效时间，没有锁就释放锁。一个客户持有锁的时候，另外的客户进来不会立刻拒绝而是会自旋等待，提高性能，锁可以重入</li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ol><li>主从复制、主从同步流程<br>从机发起 replication 请求，携带 repid（数据集 Id）和 offside，主机根据从机 repid 和自己的 repid 是否一致选择全量同步还是增量同步，全量同步时，fork 子线程执行 bgsave 生成 RDB 文件，传输到从机，从机清空数据，加载 RDB，主机生成 RDB 文件时若有新的操作，会将操作加载到一个日志文件，发送 RDB 后再发送日志文件，保证数据的一致性，增量同步时，</li><li>哨兵模式、集群脑裂<br>使用哨兵集群对集群进行监控，发现主节点下线后后，从从节点中选举新的主节点，并通知客户端要往新的主节点写。<br>集群脑裂是指因为网络等原因哨兵发现主节点下线，从从机中选举新主节点，但实际主节点并没有下线，客户端仍旧在主节点写入数据，后续网络恢复正常后，旧的主节点加入集群会变成从节点，会删除已有的所有数据，导致客户端后续写入内容的丢失。</li><li>分片集群、数据读写规则<br>Redis 有数据分片！！！<br>在该模式下，每个数据节点都是含有主从节点的集群，哈希槽，设置 key 时，更具 key 的 hash 值计算出对应的数据节点位置，并且自动路由到对应的数据节点主节点</li></ol><h1 id="二、面试题"><a href="#二、面试题" class="headerlink" title="二、面试题"></a>二、面试题</h1><p>1.<br>2. docker run –name redis -p 6379:6379 -v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;data&#x2F;:&#x2F;data&#x2F; -v &#x2F;f&#x2F;docker&#x2F;redis&#x2F;log&#x2F;redis-server.log:&#x2F;log&#x2F;redis-server.log -d redis:7.2.2 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf<br>3. docker run –name redis -p 6379:6379 -d redis:7.2.2</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="//post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html"/>
      <url>//post/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、内容整理"><a href="#一、内容整理" class="headerlink" title="一、内容整理"></a>一、内容整理</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p>当系统从磁盘中将硬盘中的某个程序代码到内存，就开启了一个进程，一个进程可以有多个线程，线程由一条一条的指令组成</p><p>进程是运行中程序的实例，包含了线程，以便同时执行多个任务<br>进程间的内存空间不是共享的，但线程中的空间对进程中的线程是共享的<br>线程更轻量，上下文切换的成本比进程更低</p><h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><p>并发是不同的线程以极短的时间在 cpu 中交替执行<br>并行是多个线程在不同的 cpu 核心中执行<br>并行是同时执行多个任务的能力，并发是可以应对多个任务的能力</p><h4 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h4><ul><li>继承 <code>Thread</code>类，重写 <code>run</code> 方法</li><li>实现 <code>Runnable</code> 接口，实现 <code>run</code> 方法</li><li>实现 <code>Callable</code> 接口，实现 <code>call</code> 方法</li><li>使用线程池创建线程</li></ul><h4 id="runnable-和-callable-有什么区别"><a href="#runnable-和-callable-有什么区别" class="headerlink" title="runnable 和 callable 有什么区别"></a>runnable 和 callable 有什么区别</h4><ul><li>Runnable 接口的方法没有返回值，Callable 接口可以有返回值，通过 FutureTask 中的 get 方法获取异步执行的返回值，但执行这个方法会阻塞主进程</li><li>Runnable 不能抛出异常，Callable 可以抛出异常</li></ul><h4 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h4><ul><li>run 只是调用普通方法，可以多次执行</li><li>start 方法会启动线程，会调用 native 的 start0 方法，只能调用一次</li></ul><h4 id="线程包括哪些状态，状态之间是如何变化的"><a href="#线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的"></a>线程包括哪些状态，状态之间是如何变化的</h4><ul><li>New</li><li>Runnable</li><li>Blocked</li><li>Waitting</li><li>TimeWaitting</li><li>Terminated</li></ul><p>创建线程时时 New 状态，调用 start 方法后会进入 Runnable 状态，Runnable 状态中会根据争抢 cpu 时间片的情况会在就绪和运行状态来回切换，如果出现需要等待锁，会进入 Blocked 状态，拿到锁后再次变成 Runnable 状态，线程中调用了 wait 方法时会进入 Waitting 状态，调用 notify 或者 notifyAll 方法后，线程被唤醒，进入 Runnable 状态，运行中遇到 sleep 会进入 TimeWaitting 状态，执行完毕或线程死亡后会进入 Terminated 状态。</p><h4 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h4><p>在 t2 中调用 t1 的 join 方法，在 t3 中调用 t2 的 join 方法</p><h4 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h4><p>notify 只会随机唤醒一个线程，notifyAll 会唤醒所有的线程</p><h4 id="在-java-中-wait-和-sleep-方法的不同？"><a href="#在-java-中-wait-和-sleep-方法的不同？" class="headerlink" title="在 java 中 wait 和 sleep 方法的不同？"></a>在 java 中 wait 和 sleep 方法的不同？</h4><ul><li>wait 是 Object 类中的方法，可以被唤醒，必须先获取 wait 对象的锁，会释放锁，</li><li>sleep 是 Thread 中的静态方法，不可以被唤醒， 不会释放锁</li></ul><h4 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h4><p>使用线程的 interrupt 方法</p><h2 id="线程中并发锁"><a href="#线程中并发锁" class="headerlink" title="线程中并发锁"></a>线程中并发锁</h2><h4 id="讲一下-synchronized-关键字的底层原理？"><a href="#讲一下-synchronized-关键字的底层原理？" class="headerlink" title="讲一下 synchronized 关键字的底层原理？"></a>讲一下 synchronized 关键字的底层原理？</h4><p>底层是由 Monitor 实现的，Moniter 是用 C++编写的，进入 synchronized 方法块时，对象锁会先关联 Monitor，Monitor 中存在三个属性，owner：持有锁的线程、entrylist：处于阻塞状态的线程 和 waitset 处于 waitting 状态的线程</p><h4 id="synchronized-关键字的底层原理-进阶"><a href="#synchronized-关键字的底层原理-进阶" class="headerlink" title="synchronized 关键字的底层原理-进阶"></a>synchronized 关键字的底层原理-进阶</h4><h4 id="你谈谈-JMM（Java-内存模型）"><a href="#你谈谈-JMM（Java-内存模型）" class="headerlink" title="你谈谈 JMM（Java 内存模型）"></a>你谈谈 JMM（Java 内存模型）</h4><p>是 java 虚拟机规范中定义的一种内存模型，每个线程中都有自己的工作内存，线程之间无法互相访问，共享的变量存放在主内存中，线程工作时，需要用到共享变量的话会在自己的工作内存中创建一个共享变量的副本，线程只能操作自己工作内存中的副本，由 JMM 负责将副本同步到共享内存和将共享变量加载到线程的工作内存中</p><h4 id="CAS-你知道吗？"><a href="#CAS-你知道吗？" class="headerlink" title="CAS 你知道吗？"></a>CAS 你知道吗？</h4><p>比较并交换，保证操作的原子性，比较旧的值相同才会将旧的值更改为新的值，CAS 中包含自旋锁，是一种乐观锁，发现旧值不相同时会不断地重置，CAS 的底层时使用 Unsafe 类中的 native 方法，</p><h4 id="请谈谈你对-volatile-的理解"><a href="#请谈谈你对-volatile-的理解" class="headerlink" title="请谈谈你对 volatile 的理解"></a>请谈谈你对 volatile 的理解</h4><ul><li>保证可见性：保证不同线程对变量操作的可见性，会强制将对副本修改的值立刻同步到主存中，其目的时防止 JIT 编译器对代码进行优化</li><li>防止指令重排：在变量的操作中加入屏障，防止其他的写操作到该变量写下面，防止其他读的操作到该变量读上面</li></ul><h4 id="什么是-AQS？"><a href="#什么是-AQS？" class="headerlink" title="什么是 AQS？"></a>什么是 AQS？</h4><p>抽象同步队列，是构建锁和同步组件的基础框架，包含了锁的状态，拿到锁的线程，等待队列的头节点和尾节点，时一种非公平锁</p><h4 id="ReentrantLock-的实现原理"><a href="#ReentrantLock-的实现原理" class="headerlink" title="ReentrantLock 的实现原理"></a>ReentrantLock 的实现原理</h4><p>是由 CAS 和 AQS 实现的，它支持公平锁和非公平锁</p><h4 id="synchronized-和-Lock-有什么区别"><a href="#synchronized-和-Lock-有什么区别" class="headerlink" title="synchronized 和 Lock 有什么区别"></a>synchronized 和 Lock 有什么区别</h4><p>synchronized 是关键字，由 c++实现，lock 是接口，由 java 语言实现<br>Lock 支持更细粒度的锁控制，功能更多，支持公平锁，可打断，可超时，多条件变量，有多种不同的实现</p><h4 id="死锁产生的条件以及死锁排查方案"><a href="#死锁产生的条件以及死锁排查方案" class="headerlink" title="死锁产生的条件以及死锁排查方案"></a>死锁产生的条件以及死锁排查方案</h4><p>线程中同时获取多把锁的情况，jps 获取线程的 PID，再用 jstack 获取线程的运行情况</p><h4 id="聊一下-ConcurrentHashMap"><a href="#聊一下-ConcurrentHashMap" class="headerlink" title="聊一下 ConcurrentHashMap"></a>聊一下 ConcurrentHashMap</h4><p>是线程安全版本的 HashMap，数据结构和 HashMap 一样，它在空节点插入时是 CAS 的操作，在链表或者红黑树的节点是锁的头节点。</p><h4 id="导致并发程序出现问题的根本原因是什么"><a href="#导致并发程序出现问题的根本原因是什么" class="headerlink" title="导致并发程序出现问题的根本原因是什么"></a>导致并发程序出现问题的根本原因是什么</h4><p>并发编程三大特性是</p><ul><li>原子性：线程要么执行要么不执行</li><li>可见性：对数据副本的修改能及时同步到别的线程</li><li>有序性：防止指令重排<br>违反了特性就可能产生问题</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="说一下线程池的核心参数（线程池的执行原理知道嘛）"><a href="#说一下线程池的核心参数（线程池的执行原理知道嘛）" class="headerlink" title="说一下线程池的核心参数（线程池的执行原理知道嘛）"></a>说一下线程池的核心参数（线程池的执行原理知道嘛）</h4><p>线程池有七大参数</p><ul><li>核心线程池数</li><li>最大线程数</li><li>非核心线程存活时间</li><li>非核心线程存活时间单位</li><li>阻塞队列</li><li>线程工厂</li><li>拒绝策略</li></ul><p>其中拒绝策略是达到最大先乘除，并且阻塞队列也满了的时候拒绝策略分为</p><ul><li>AbortPolicy：直接抛出异常，默认策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务</li></ul><h4 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h4><p>常见的有 ArrayBlokingQueue 和 LinkedBlokingQueue<br>不同之处：</p><ul><li>ArrayBlokingQueue 是有界的，LinkedBlokingQueue 则是可以设置为无界</li><li>ArrayBlokingQueue 只有一把锁，锁整个数组，而 LinkedBlokingQueue 有头节点和尾节点两把锁，相对来说加入和取出元素的时候 LinkedBlokingQueue 效率更高一些</li></ul><h4 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h4><ul><li>高并发，任务时间短：N+1，可以减少上下文切换</li><li>并发不高，任务时间较长<ul><li>IO 密集型的任务使用 2N+1</li><li>cpu 密集型使用 N+1</li></ul></li></ul><h4 id="为什么不建议用-Executors-创建线程池"><a href="#为什么不建议用-Executors-创建线程池" class="headerlink" title="为什么不建议用 Executors 创建线程池"></a>为什么不建议用 Executors 创建线程池</h4><p>记得 java 开发手册里这个是强制的，因为 Executors 创建的线程有最大线程数、阻塞队列的长度为 Integer.MAX_VALUE 的，可能会导致 OOM</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h4 id="线程池使用场景"><a href="#线程池使用场景" class="headerlink" title="线程池使用场景"></a>线程池使用场景</h4><ul><li>使用 java 操作大量的数据的时候，操作全部可能导致 OOM，可以使用 CountDownLatch 和线程池分成一个一个的任务执行</li><li>数据汇总，当一个接口需要多个远程调用时，可以将多个调用提交到线程池中同步执行，提高速度</li><li>异步调用，一个接口值的返回不需要等某一个方法执行结束，比如搜索内容是，记录搜索记录和返回搜索结果，添加记录可以提交到线程池中异步执行</li></ul><h4 id="如何控制某个方法允许并发访问线程的数量"><a href="#如何控制某个方法允许并发访问线程的数量" class="headerlink" title="如何控制某个方法允许并发访问线程的数量"></a>如何控制某个方法允许并发访问线程的数量</h4><p>使用 Semaphore，保存的是一个信号量，进入线程的时候请求信号，信号量-1，只有信号量大于 0 才能请求成功，方法结束后，调用释放信号的方法，把信号量加回去。</p><h2 id="谈谈你对-ThreadLocal-的理解"><a href="#谈谈你对-ThreadLocal-的理解" class="headerlink" title="谈谈你对 ThreadLocal 的理解"></a>谈谈你对 ThreadLocal 的理解</h2><p>ThreadLocal 是解决线程安全的一个操作类，将数据存储到各自线程中，有 set，get 和 remove 三个主要方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//post/MarkDown_All_In_One.html"/>
      <url>//post/MarkDown_All_In_One.html</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="二级标题-ignore-true"><a href="#二级标题-ignore-true" class="headerlink" title="二级标题 {ignore&#x3D;true}"></a>二级标题 {ignore&#x3D;true}</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h1><p><em>强调文本</em><br><strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is 是液体。</p><p>2^10^ 运算结果是 1024</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目 1</li><li>项目 2</li><li>项目 3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片: <img src="https://img-home.csdnimg.cn/images/20220524100510.png" alt="Alt"></p><p>带尺寸的图片: ![Alt](<a href="https://img-home.csdnimg.cn/images/20220524100510.png">https://img-home.csdnimg.cn/images/20220524100510.png</a> &#x3D;60x60)</p><p>宽度确定高度等比例的图片: ![Alt](<a href="https://img-home.csdnimg.cn/images/20220524100510.png">https://img-home.csdnimg.cn/images/20220524100510.png</a> &#x3D;60x)</p><p>高度确定宽度等比例的图片: ![Alt](<a href="https://img-home.csdnimg.cn/images/20220524100510.png">https://img-home.csdnimg.cn/images/20220524100510.png</a> &#x3D;x60)</p><p>居中的图片: <img src="https://img-home.csdnimg.cn/images/20220524100510.png#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://img-home.csdnimg.cn/images/20220524100510.png#pic_center">https://img-home.csdnimg.cn/images/20220524100510.png#pic_center</a> &#x3D;60x60)</p><p>居右的图片: <img src="https://img-home.csdnimg.cn/images/20220524100510.png#pic_right" alt="Alt"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接: <a href="https://www.csdn.net/">link</a></p><h1 id="代码片"><a href="#代码片" class="headerlink" title="代码片"></a>代码片</h1><p>下面展示一些 <code>内联代码片</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An highlighted block</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><table><thead><tr><th align="center">Column 1</th><th align="right">Column 2</th></tr></thead><tbody><tr><td align="center">centered 文本居中</td><td align="right">right-aligned 文本居右</td></tr></tbody></table><h1 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h1><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^1</a></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Markdown 将文本转换为 HTML。</p><p>*[HTML]: 超文本标记语言</p><h1 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h1><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>: John</dt><dd>Luke</dd></dl><h1 id="LaTeX-数学公式"><a href="#LaTeX-数学公式" class="headerlink" title="LaTeX 数学公式"></a>LaTeX 数学公式</h1><p>Gamma 公式展示 $\Gamma(n) &#x3D; (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过 Euler integral</p><p>$$<br>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><h1 id="插入甘特图"><a href="#插入甘特图" class="headerlink" title="插入甘特图"></a>插入甘特图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">        section 现有任务</span><br><span class="line">        已完成               :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        进行中               :active,  des2, 2014-01-09, 3d</span><br><span class="line">        计划中               :         des3, after des2, 5d</span><br></pre></td></tr></table></figure><h1 id="插入-UML-图"><a href="#插入-UML-图" class="headerlink" title="插入 UML 图"></a>插入 UML 图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span><br><span class="line">李四--&gt;&gt;王五: 你最近怎么样，王五？</span><br><span class="line">李四--x 张三: 我很好，谢谢!</span><br><span class="line">李四-x 王五: 我很好，谢谢!</span><br><span class="line">Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line"></span><br><span class="line">李四--&gt;&gt;张三: 打量着王五...</span><br><span class="line">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure><h1 id="插入-Mermaid-流程图"><a href="#插入-Mermaid-流程图" class="headerlink" title="插入 Mermaid 流程图"></a>插入 Mermaid 流程图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><h1 id="插入-Flowchart-流程图"><a href="#插入-Flowchart-流程图" class="headerlink" title="插入 Flowchart 流程图"></a>插入 Flowchart 流程图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure><h1 id="插入-classDiagram-类图"><a href="#插入-classDiagram-类图" class="headerlink" title="插入 classDiagram 类图"></a>插入 classDiagram 类图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    Class01 &lt;|-- AveryLongClass : Cool</span><br><span class="line">    &lt;&lt;interface&gt;&gt; Class01</span><br><span class="line">    Class09 --&gt; C2 : Where am i?</span><br><span class="line">    Class09 --* C3</span><br><span class="line">    Class09 --|&gt; Class07</span><br><span class="line">    Class07 : equals()</span><br><span class="line">    Class07 : Object[] elementData</span><br><span class="line">    Class01 : size()</span><br><span class="line">    Class01 : int chimp</span><br><span class="line">    Class01 : int gorilla</span><br><span class="line">    class Class10 &#123;</span><br><span class="line">        &gt;&gt;service&gt;&gt;</span><br><span class="line">        int id</span><br><span class="line">        size()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//post/skywalking.html"/>
      <url>//post/skywalking.html</url>
      
        <content type="html"><![CDATA[<p>docker run –name skywalking-oap-server –restart always -e TZ&#x3D;Asia&#x2F;Shanghai –link elasticsearch7:elasticsearch7 -e SW_STORAGE&#x3D;elasticsearch -e SW_STORAGE_ES_CLUSTER_NODES&#x3D;elasticsearch7:9200 -d -p 12800:12800 -p 11800:11800 apache&#x2F;skywalking-oap-server</p><p>docker run -d –name skywalking-ui –restart&#x3D;always -e TZ&#x3D;Asia&#x2F;Shanghai -p 8088:8080 –link skywalking-oap:oap -e SW_OAP_ADDRESS&#x3D;<a href="http://oap:12800/">http://oap:12800</a> apache&#x2F;skywalking-ui<br>docker run -d –name skywalking-ui –restart&#x3D;always -e TZ&#x3D;Asia&#x2F;Shanghai -p 8088:8080 –link skywalking-oap-server:skywalking-oap-server -e SW_OAP_ADDRESS&#x3D;<a href="http://localhost:12800/">http://localhost:12800</a> apache&#x2F;skywalking-ui</p><p>docker run -d –name skywalking-ui –restart&#x3D;always -e TZ&#x3D;Asia&#x2F;Shanghai -p 8080:8080 –link skywalking-oap:oap -e SW_OAP_ADDRESS&#x3D;<a href="http://oap:12800/">http://oap:12800</a> apache&#x2F;skywalking-ui:9.2.0</p><p>-DSW_AGENT_NAME&#x3D;dispatcher-service -DSW_AGENT_COLLECTOR_BACKEND_SERVICES&#x3D;127.0.0.1:11800 -javaagent:D:\softWare\apache-skywalking-java-agent-8.16.0\skywalking-agent\skywalking-agent.jar</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="//post/dockerCmd.html"/>
      <url>//post/dockerCmd.html</url>
      
        <content type="html"><![CDATA[<p><code>docker run -d --name nacos -p 3333:8848 -p 4333:9848 -p 9849:9849 --privileged=true -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -v /f/docker/nacos/logs/:/home/nacos/logs -v /f/docker/nacos/conf/:/home/nacos/conf/ nacos/nacos-server:v2.2.0</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//post/hello-world.html"/>
      <url>//post/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
